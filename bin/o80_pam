#!/usr/bin/env python3

import sys
import os
import time
import threading
import multiprocessing
import o80
import o80_pam
import pam_interface


_DEFAULT_FREQUENCY = 2000.0
_DEFAULT_MUJOCO_ID = o80_pam.mujoco_id
_DEFAULT_SEGMENT_ID = o80_pam.segment_ids.robot
_NB_DOFS = 4
_WINDOW_SIZE = (1200,1000) # plotting
_DATA_SIZE = 2000 # plotting


#Hosts global variables:
#    - _running : to be set to false to stop console,
#               plotting and standalone
#    - _error : global error message to be displayed
#               in the console
class _Monitor:

    _running = True
    _error = None

    @classmethod
    def running(cls):
        return cls._running
    
    @classmethod
    def stop(cls):
        cls._running = False

    @classmethod
    def error(cls):
        return cls._error

    @classmethod
    def set_error(cls,error):
        cls._error = str(error)


#    Create a frontend on the segment_id, get observations
#    and displays important information on the terminal.
def _console(segment_id,
             config):

    import curses

    # printing segment id
    permanent_info = "\n\to80 pam | segment_id: " + segment_id
    if config.bursting:
        permanent_info += " (bursting mode)"
    permanent_info += str("\n\t(close the plot and press 'q' to exit, "+
                          "run with '-h' for options)\n")

    # returning "status", i.e. a string
    # providing desired and observed pressures
    # for each muscle, at well as iteration number and frequency
    # of the standalone.
    def _get_status(frontend,config):
        observation = frontend.latest()
        iteration = observation.get_iteration()
        frequency = observation.get_frequency()
        observed = observation.get_observed_pressures()
        desired = observation.get_desired_pressures()
        ref_founds = observation.get_references_found()
        positions = observation.get_positions()
        for dof,found in enumerate(ref_founds):
            if not found:
                positions[dof]=None
        s = ["iteration: "+str(iteration)+" | frequency "+str(frequency)+"\n"]
        for dof in range(config.nb_dofs):
            d = [dof]
            for ago in [0,1]:
                d.append([observed[dof][ago],
                          desired[dof][ago]])
            position = positions[dof]
            if position is None:
                d.append("*")
            else :
                d.append(position)
            d = "\t".join([str(d_) for d_ in d])
            s.append(d)
        if _Monitor.error() is not None:
            s.append("\nERROR DETECTED:\n\t"+_Monitor.error())
        return "\t"+"\n\t".join(s),observed

    # manages curses : creates the o80 frontend that is
    # used to extract observation from the robot, and
    # display related selected information in the terminal
    class _Console:

        _nb_dofs = config.nb_dofs
        _screen = None
        _should_exit = False
        _monitor_exit_thread = None
        _min_pressure = 0
        _max_pressure = config.get_max_pressure()
        _width = None
        _frontend = None

        # creating frontend and initializing curse
        @classmethod
        def init(cls,
                 segment_id,
                 width = 100):
            cls._frontend = o80_pam.FrontEnd(segment_id)
            cls._width = width
            cls._screen = curses.initscr()
            curses.noecho()
            curses.curs_set(0)
            curses.start_color()
            curses.use_default_colors()
            curses.init_pair(1,curses.COLOR_GREEN,-1)
            curses.init_pair(2,curses.COLOR_BLUE,-1)
            cls._screen.keypad(1)
            cls._monitor_exit_thread = threading.Thread(target=cls._monitor_exit)
            cls._monitor_exit_thread.setDaemon(True)
            cls._monitor_exit_thread.start()

        # detecting if 'q' was pressed, which set _should_exit
        # to True, which will stop the loop
        @classmethod
        def _monitor_exit(cls):
            while not cls._should_exit:
                event = cls._screen.getch()
                if event == ord("q"): cls._should_exit=True

        # closing curses
        @classmethod
        def exit(cls):
            curses.endwin()

        # the method that generates the "pressure bars"
        # for each of the dof
        @classmethod
        def _get_dof_str(cls,
                         dof,
                         pressure_plus,
                         pressure_minus):

            def _get_pressure_str(pressure,
                                  min_pressure,
                                  max_pressure,
                                  width):
                mdiff = (max_pressure-min_pressure)
                diff = pressure-min_pressure
                value = int (width*(diff)/mdiff)
                return '|'*value

            r = []
            for sign,pressure in zip(('+','-'),(pressure_plus,pressure_minus)):
                value = _get_pressure_str( pressure,
                                           cls._min_pressure,
                                           cls._max_pressure,
                                           cls._width) 
                r.append("\t"+str(dof)+sign+"  "+str(value))

            return '\n'.join(r)


        # The method the construct and display the
        # string information
        @classmethod
        def refresh(cls):
            if cls._should_exit:
                return
            status,pressures  = _get_status(cls._frontend,config)
            cls._screen.clear()
            cls._screen.addstr(permanent_info+"\n")
            # the "pressure bars"
            for dof in range(config.nb_dofs):
                cls._screen.addstr( cls._get_dof_str(dof,
                                                     pressures[dof][0],
                                                     pressures[dof][1]) )
                cls._screen.addstr('\n\n')
            # the status (iteration, frequency, observed/desired pressues)
            cls._screen.addstr(status)
            cls._screen.refresh()

    _Console.init(config.segment_id)

    # running until 'q' is pressed.
    # calls "_Monitor.stop" to trigger
    # the stop of the plotting and of the
    # o80 standalone
    while _Monitor.running() :
        if _Console._should_exit:
            _Monitor.stop()
            break
        _Console.refresh()
        time.sleep(0.05)

    _Console.exit()


# creates 5 dynamic plots: 1 per dof (observed/desired pressure
# for agonist and antagonist muscles + position) + frequency
# uses fyplot (pip3 install fyplot)
def _plot(segment_id,
          frequency,
          config,
          nb_dofs,
          window,
          data_size):

    from fyplot import dict_plot

    config = dict_plot.Config()

    # 1 subplot per dof
    config.channels = [str(dof)
                       for dof in range(nb_dofs)]
    # 1 subplot for frequency
    config.channels.append("frequency")

    # for the dof plots: y limit of pressures between
    # 0 and 30000
    lim_min = 0
    lim_max = 30000
    config.limits = {str(dof):(lim_min,lim_max)
                     for dof in range(nb_dofs)}

    # for frequency: y limits in Hz up to 2x
    # the expected frequency
    config.limits["frequency"]=(0,
                                2*frequency)

    # each dof subplot will displays these pressures + position:
    # (position, in radian, will be cast to (min_pressure,max_pressure)
    # to fit in the y limits
    for dof in range(nb_dofs):
        config.slots[str(dof)] = ["desired_ago","observed_ago",
                                  "desired_antago","observed_antago",
                                  "position"]

    # the frequency subplot 
    config.slots["frequency"] = ["frequency"]

    # colors. Ago: red, Antago: green
    #         observed: strong color, desired: ligher color
    #         position : some kind of pink
    #         frequency: blue
    config.slots_colors = {}
    config.slots_colors["desired_ago"] = (150,0,0)
    config.slots_colors["observed_ago"] = (255,0,0)
    config.slots_colors["desired_antago"] = (0,150,0)
    config.slots_colors["observed_antago"] = (0,255,0)
    config.slots_colors["position"] = (255, 100, 242)
    config.slots_colors["frequency"] = (0,255,0)

    # x axis: how many data point
    config.data_size = data_size
    config.title = segment_id
    config.windows_size = window

    # creates a o80 frontend, and uses it to get observation
    # and "feeding" the plots
    def run():

        class Holder:
            frontend = o80_pam.FrontEnd(segment_id)
            previous_iteration = None
            data = {}
            dofs = [str(dof) for dof in range(nb_dofs)]

        # position is in degrees between -180 and +180.
        # casting it to [lim_min,lim_max]
        def norm_position(position,lim_min=0,lim_max=30000):
            p = float(position) / 360.0
            diff = float(lim_max-lim_min)
            mid = diff/2.
            p = mid+p*diff
            return int(p+0.5)

        def update_data():
            observation =  Holder.frontend.latest()
            iteration = observation.get_iteration()
            if iteration == Holder.previous_iteration:
                Holder.data = {}
            Holder.previous_iteration = iteration
            observed_pressures = observation.get_observed_pressures()
            desired_pressures = observation.get_desired_pressures()
            positions = observation.get_positions()
            frequency = observation.get_frequency()
            for dof,observed,desired,position in zip(Holder.dofs,
                                                     observed_pressures,
                                                     desired_pressures,
                                                     positions):
                Holder.data[dof]={"desired_ago":desired[0],
                                  "desired_antago":desired[1],
                                  "observed_ago":observed[0],
                                  "observed_antago":observed[1]}
                if position is not None:
                    Holder.data[dof]["position"]=norm_position(position)
            Holder.data["frequency"]={"frequency":frequency}
            
        # running until keyboard interrupt
        # (warning: may not be detected) or
        # until 'q' is pressed (if the terminal console runs,
        # as curses will detect 'q', close the console, which will
        # set _Monitor.running to False, which should close the
        # loop below
        try:
            while _Monitor.running():
                update_data()
                if Holder.data:
                    dict_plot.set_data(Holder.data)
                time.sleep(0.001)
        except KeyboardInterrupt:
            pass
        except Exception as e:
            import traceback
            trace = traceback.format_exc()
            error = str(e)+"\n"+str(trace)
            _Monitor.set_error("o80 pam plotting error: "+error)
        
    try :
        dict_plot.start_plotting(config,run)
    except Exception as e :
        _Monitor.set_error("o80 pam plotting error: "+str(e))


def _start_mujoco(mujoco_id,segment_id,bursting_mode):

    import pam_mujoco
    import pam_models
    
    def _execute_mujoco(pam_model_config,robot,bursting,
                    mujoco_id,model_name):
        # init mujoco
        config = pam_mujoco.MujocoConfig()
        config.graphics = True
        config.extended_graphics = False
        config.realtime = True
        pam_mujoco.init_mujoco(config)
        # adding pressure controller
        pam_mujoco.add_pressure_controller(*pam_model_config)
        # bursting mode
        if bursting:
            pam_mujoco.add_bursting(mujoco_id,segment_id)
        # starting the mujoco thread
        pam_mujoco.execute(mujoco_id,model_name)
        # runnign it until requested to stop
        while not pam_mujoco.is_stop_requested(mujoco_id):
            time.sleep(0.01)

    model_name = segment_id
    items = pam_mujoco.model_factory(model_name,robot1=True)
    robot = items["robot"]

    # pam model configuration
    pam_model_config_path= pam_models.get_default_config_path()
    a_init = [0.5]*8
    l_MTC_change_init = [0.0]*8
    scale_max_activation = 1.0
    scale_max_pressure = 24000
    scale_min_activation = 0.001
    scale_min_pressure = 6000
    pam_model_config = [ segment_id,robot.joint,
                         scale_min_pressure,scale_max_pressure,
                         scale_min_activation, scale_max_activation,
                         pam_model_config_path,pam_model_config_path,
                         a_init,l_MTC_change_init ]
    
    # starting the mujoco thread
    process  = multiprocessing.Process(target=_execute_mujoco,
                                       args=(pam_model_config,robot,
                                             bursting_mode,mujoco_id,model_name,))
    pam_mujoco.clear(mujoco_id)
    process.start()
    pam_mujoco.wait_for_mujoco(mujoco_id)
    return process


            
# creates an o80 Standalone, and starts
# the console and the plotting. config : instance of _Config
def _start_robot(config):

    segment_id = config.segment_id
    frequency = config.frequency
    bursting_mode = config.bursting
    pam_config = config.config
    mode = config.mode
    mujoco_id = config.mujoco_id

    # starting from a clean state
    o80.clear_shared_memory(segment_id)

    # starting the standalone
    if mode==config.DUMMY:
        o80_pam.dummy_start_standalone(segment_id,
                                       frequency,
                                       bursting_mode,
                                       pam_config)
    if mode==config.REAL:
        o80_pam.real_start_standalone(segment_id,
                                      frequency,
                                      bursting_mode,
                                      pam_config)
    mujoco_process=None
    if mode==config.MUJOCO:
        try:
            import pam_mujoco
        except:
            error = str("Failed to import pam_mujoco.\n"+
                        "You may try: treep --clone PAM_MUJOCO\n"+
                        "and recompile"+
                        "(you need also a mujoco licence file in /opt/mujoco/)")
            raise Exception(error)
        mujoco_process = _start_mujoco(mujoco_id,segment_id,bursting_mode)

    # setting desired pressures to config minimal pressures
    frontend = o80_pam.FrontEnd(segment_id)
    for dof in range(config.nb_dofs):
        min_ago = pam_config.min_pressure(dof,pam_interface.sign.agonist)
        min_antago = pam_config.min_pressure(dof,pam_interface.sign.antagonist)
        frontend.add_command(dof,min_ago,min_antago,o80.Mode.OVERWRITE)
    frontend.pulse()
    del frontend

    # starting plotting
    if config.plotting:
        plotting = threading.Thread(target=_plot,args=(segment_id,
                                                       frequency,
                                                       config.config,
                                                       config.nb_dofs,
                                                       config.window,
                                                       config.data_size,))
        plotting.start()
    
    # starting the console    
    if config.console:
        _console(segment_id,
                 config)
    else:
        try:
            while _Monitor.running():
                time.sleep(0.05)
        except KeyboardInterrupt:
            _Monitor.stop()
            if mujoco_process is not None:
                pam_mujoco.request_stop(segment_id)
                if bursting_mode:
                    frontend.final_burst()
                mujoco_process.join()

            pass


    # setting desired pressures to config minimal pressures
    frontend = o80_pam.FrontEnd(segment_id)
    for dof in range(config.nb_dofs):
        min_ago = pam_config.min_pressure(dof,pam_interface.sign.agonist)
        min_antago = pam_config.min_pressure(dof,pam_interface.sign.antagonist)
        frontend.add_command(dof,min_ago,min_antago,
                             o80.Speed.per_second(2000),o80.Mode.OVERWRITE)
    frontend.pulse_and_wait()
    del frontend

    o80_pam.stop_standalone(segment_id)

        
        

class _Config:

    DUMMY=0
    MUJOCO=1
    REAL=2
    
    def __init__(self):
        self.mode = self.DUMMY
        self.segment_id = _DEFAULT_SEGMENT_ID
        self.nb_dofs = _NB_DOFS
        self.frequency = _DEFAULT_FREQUENCY
        self.bursting = False
        # if False : plotting will not be started
        self.plotting = True
        # if False : (curses) console will not be started
        self.console = True
        # pam_interface config
        # path to the json file
        self.config_path = None
        # instance of pam_interface::Configuration
        self.config = None
        # for plotting
        self.window = _WINDOW_SIZE
        self.data_size = _DATA_SIZE
        # for stopping mujoco
        self.mujoco_id = _DEFAULT_MUJOCO_ID
        
    def get_min_pressure(self):
        return min([min(self.config.min_pressures_ago),
                    min(self.config.min_pressures_antago)])

    def get_max_pressure(self):
        return max([max(self.config.max_pressures_ago),
                    max(self.config.max_pressures_antago)])
    
    def display(self):

        if self.mode==self.DUMMY:
            s = "\nstarting dummy robot "+str(self.segment_id)
        if self.mode==self.REAL:
            s = "\nstarting real robot "+str(self.segment_id)
        if self.mode==self.MUJOCO:
            s = "\nstarting mujoco robot "+str(self.segment_id)
        s += "\n\tbursting mode:\t"+str(self.bursting)
        s += "\n\tfrequency:\t"+str(self.frequency)
        print(s)
        self.config.display()
        
        
        
# parse the args and returns an
# instance of _Config
def _parse_args(args):

    config = _Config()
    
    if "real" in args:
        config.mode = config.REAL

    if "mujoco" in args:
        config.mode = config.MUJOCO

    if "no-plotting" in args:
        config.plotting = False
      
    if "no-console" in args:
        config.console = False

    if "bursting" in args:
        config.bursting = True
    
    args = [a for a in args if not
            a in ("real","mujoco","no-plotting","bursting","no-console")]

    used_args = []
    for arg in args:
        if os.path.isfile(arg):
            config.config_path = arg
            used_args.append(arg)
        try :
            config.frequency = int(arg)
            used_args.append(arg)
        except:
            pass

    args = [a for a in args if a not
            in used_args]

    if len(args)>1:
        raise Exception("failed to parse arguments: too many of them !")

    if len(args)==1:
        config.segment_id = args[0]

    if config.config_path is None:
        config.config = pam_interface.DefaultConfiguration()
    else :
        config.config = pam_interface.JsonConfiguration(config.config_path)
        
    return config


def _help():

    print("\n\tusage: pam_robot segment_id real frequency bursting "+
          "config_path no-plotting no-console\n")
    print("\tall arguments are optional and can be provided in any order\n")
    print("\t\tsegment_id: default: 'o80_pam'")
    print("\t\tmode: if equal to 'real', a real robot standalone will")
    print("\t\t      be started, if equal to 'mujoco', a mujoco standalone")
    print("\t\t      will be started. default: dummy standalone started")
    print("\t\tfrequency: int, frequency of the standalone, default: "
          +str(_DEFAULT_FREQUENCY)+"Hz")
    print("\t\tbursting: if equal to 'bursting', the standalone will be")
    print("\t\t          started in bursting mode")
    print("\t\tconfig_path: if equal to a valid file path, a corresponding instance")
    print("\t\t             of pam_interface::JsonConfiguration will be used,\n"
          +"\t\t            default: instance of pam_interface::DefaultConfiguration")
    print("\t\tno-plotting: if equal to 'no-plotting', plotting will not be started")
    print("\t\tno-console: if equal to 'no-console', console will not be started")
    print("\n")


def _run(args):

    if any([s in args
            for s in ("help","--help","-help","-h","--h","man")]):
        _help()
        return
    
    config = _parse_args(args)
    config.display()

    # console will be started from _start_robot
    _start_robot(config)

    
if __name__ == "__main__":

    args = sys.argv[1:]
    _run(args)
        
