#!/usr/bin/env python3

import time
import sys
import threading
import o80
import o80_pam
import pam_interface

_DEFAULT_FREQUENCY = 1000.0
_DEFAULT_SEGMENT_ID = "o80_pam"
_NB_DOFS = 4
_WINDOW_SIZE = (1200,1000) # plotting
_DATA_SIZE = 1000 # plotting


def _console(segment_id,
             config):

    import curses

    permanent_info = "o80 pam | segment_id: " + segment_id +"\n"

    def _get_status(frontend,config):
        observation = frontend.latest()
        iteration = observation.get_iteration()
        frequency = observation.get_frequency()
        observed = observation.get_observed_pressures()
        desired = observation.get_desired_pressures()
        ref_founds = observation.get_references_found()
        positions = [0]*config.nb_dofs
        for dof,found in enumerate(ref_founds):
            if not found:
                positions[dof]=None
        s = ["iteration: "+str(iteration)+" | frequency "+str(frequency)]
        for dof in range(config.nb_dofs):
            d = [dof]
            for ago in [0,1]:
                d.append([observed[dof][ago],
                          desired[dof][ago]])
            position = positions[dof]
            if position is None:
                d.append("*")
            else :
                d.append(position)
            d = "\t".join([str(d_) for d_ in d])
            s.append(d)
        return "\n".join(s),observed
                
    class _Console:

        _nb_dofs = config.nb_dofs
        _screen = None
        _should_exit = False
        _monitor_exit_thread = None
        _min_pressure = config.get_min_pressure()
        _max_pressure = config.get_max_pressure()
        _width = None
        _frontend = None
        
        @classmethod
        def init(cls,
                 segment_id,
                 width = 100):
            cls._frontend = o80_pam.FrontEnd(segment_id)
            cls._width = width
            cls._screen = curses.initscr()
            curses.noecho()
            curses.curs_set(0)
            curses.start_color()
            curses.use_default_colors()
            curses.init_pair(1,curses.COLOR_GREEN,-1)
            curses.init_pair(2,curses.COLOR_BLUE,-1)
            cls._screen.keypad(1)
            cls._monitor_exit_thread = threading.Thread(target=cls._monitor_exit)
            cls._monitor_exit_thread.setDaemon(True)
            cls._monitor_exit_thread.start()
            
        @classmethod
        def _monitor_exit(cls):
            while not cls._should_exit:
                event = cls._screen.getch()
                if event == ord("q"): cls._should_exit=True

        @classmethod
        def exit(cls):
            curses.endwin()

        @classmethod
        def _get_dof_str(cls,
                         dof,
                         pressure_plus,
                         pressure_minus):

            def _get_pressure_str(pressure,
                                  min_pressure,
                                  max_pressure,
                                  width):
                mdiff = (max_pressure-min_pressure)
                diff = pressure-min_pressure
                value = int (width*(diff)/mdiff)
                return '|'*value

            r = []
            for sign,pressure in zip(('+','-'),(pressure_plus,pressure_minus)):
                value = _get_pressure_str( pressure,
                                           cls._min_pressure,
                                           cls._max_pressure,
                                           cls._width) 
                r.append(str(dof)+sign+"  "+str(value))

            return '\n'.join(r)


        @classmethod
        def refresh(cls):
            if cls._should_exit:
                return
            status,pressures  = _get_status(cls._frontend,config)
            cls._screen.clear()
            cls._screen.addstr(permanent_info+"\n")
            for dof in range(config.nb_dofs):
                cls._screen.addstr( cls._get_dof_str(dof,
                                                     pressures[dof][0],
                                                     pressures[dof][1]) )
                cls._screen.addstr('\n\n')
            cls._screen.addstr(status)
            cls._screen.refresh()

    _Console.init(config.segment_id)

    while True :
        if _Console._should_exit:
            break
        _Console.refresh()
        time.sleep(0.05)

    _Console.exit()

    

def _start_robot(config,
                 console):

    segment_id = config.segment_id
    frequency = config.frequency
    bursting_mode = config.bursting
    pam_config = config.config
    dummy = config.dummy
    
    o80.clear_shared_memory(segment_id)

    if dummy:
        o80_pam.dummy_start_standalone(segment_id,
                                       frequency,
                                       bursting_mode,
                                       pam_config)
    else:
        o80_pam.real_start_standalone(segment_id,
                                      frequency,
                                      bursting_mode,
                                      pam_config)
        
    if console:
        _console(segment_id,
                 config)
    else:
        try:
            while True:
                time.sleep(0.05)
        except KeyboardInterrupt:
            pass

    o80_pam.stop_standalone(segment_id)

        
def _plot(segment_id,
          frequency,
          config,
          nb_dofs,
          window,
          data_size):

    from fyplot import dict_plot
    
    config = dict_plot.Config()

    config.channels = [str(dof)
                       for dof in range(nb_dofs)]
    config.channels.append("frequency")
    
    config.limits = {str(dof):(0,30000)
                     for dof in range(nb_dofs)}
    config.limits["frequency"]=(0,
                                2*frequency)

    for dof in range(nb_dofs):
        config.slots[str(dof)] = ["desired_ago","observed_ago",
                                  "desired_antago","observed_antago",
                                  "position"]
    config.slots["frequency"] = ["frequency"]

    config.slots_colors = {}
    config.slots_colors["desired_ago"] = (150,0,0)
    config.slots_colors["observed_ago"] = (255,0,0)
    config.slots_colors["desired_antago"] = (0,150,0)
    config.slots_colors["observed_antago"] = (0,255,0)
    config.slots_colors["position"] = (100,100,255)
    config.slots_colors["frequency"] = (0,255,0)
    
    config.data_size = data_size
    config.title = segment_id
    config.windows_size = window

    def run():

        class Holder:
            frontend = o80_pam.FrontEnd(segment_id)
            previous_iteration = None
            data = {}
            dofs = [str(dof) for dof in range(nb_dofs)]
        
        def update_data():
            observation =  Holder.frontend.latest()
            iteration = observation.get_iteration()
            if iteration == Holder.previous_iteration:
                Holder.data = None
            Holder.previous_iteration = iteration
            observed_pressures = observation.get_observed_pressures()
            desired_pressures = observation.get_desired_pressures()
            positions = observation.get_positions()
            frequency = observation.get_frequency()
            for dof,observed,desired,position in zip(Holder.dofs,
                                                     observed_pressures,
                                                     desired_pressures,
                                                     positions):
                Holder.data[dof]={"desired_ago":desired[0],
                                  "desired_antago":desired[1],
                                  "observed_ago":observed[0],
                                  "observed_antago":observed[1]}
                if position is not None:
                    Holder.data[dof]["position"]=position
            Holder.data["frequency"]={"frequency":frequency}
            
        
        try:
            while True:
                update_data()
                if Holder.data is not None:
                    dict_plot.set_data(Holder.data)
                time.sleep(0.001)
        except KeyboardInterrupt:
            pass

    dict_plot.start_plotting(config,run)


class _Config:

    def __init__(self):
        # real robot if false
        self.dummy = True
        self.segment_id = _DEFAULT_SEGMENT_ID
        self.nb_dofs = _NB_DOFS
        self.frequency = _DEFAULT_FREQUENCY
        self.bursting = False
        # if true : does not start a
        # standalone, starts plotting
        self.plotting = False
        # pam_interface config
        self.config_path = None
        self.config = None
        # for plotting
        self.window = _WINDOW_SIZE
        self.data_size = _DATA_SIZE

    def get_min_pressure(self):
        return min([min(self.config.min_pressures_ago),
                    min(self.config.min_pressures_antago)])

    def get_max_pressure(self):
        return max([max(self.config.max_pressures_ago),
                    max(self.config.max_pressures_antago)])
    
    def display(self):

        if self.plotting:
            print("plotting: "+str(self.segment_id))

        if self.dummy:
            s = "starting dummy robot "+str(self.segment_id)
        else:
            s = "starting real robot "+str(self.segment_id)
        s += "\n\tbursting mode:\t"+str(self.bursting)
        s += "\n\tfrequency:\t"+str(self.frequency)
        print(s)
        self.config.display()
        
        
        
# parse the args and returns an
# instance of _Config
def _parse_args(args):

    config = _Config()
    
    if "real" in args:
        config.dummy = False

    if "plotting" in args:
        config.plotting = True

    if "bursting" in args:
        config.bursting = True

        
    args = [a for a in args if not
            a in ("real","plotting","bursting")]

    used_args = []
    for arg in args:
        if os.path.isfile(arg):
            _Config.config_path = arg
            used_args.append(arg)
        try :
            _Config.frequency = int(arg)
            used_args.append(arg)
        except:
            pass

    args = [a for a in args if a not
            in used_args]

    if len(args)>1:
        raise Exception("failed to parse arguments: too many of them !")

    if len(args)==1:
        config.segment_id = args[0]

    if config.config_path is None:
        config.config = pam_interface.DefaultConfiguration()
    else :
        config.config = pam_interface.JsonConfiguration(config.config_path)
        
    return config


def _help():

    print("\n\tusage: pam_robot segment_id real frequency bursting config_path plotting")
    print("\tall arguments are optional and can provided in any order")
    print("\t\tsegment_id: default: 'o80_pam'")
    print("\t\treal: if equal to 'real', a real robot standalone will")
    print("\t\t      be started, default: dummy standalone started")
    print("\t\tfrequency: int, frequency of the standalone, default: 1000Hz")
    print("\t\tbursting: if equal to 'bursting', the standalone will be")
    print("\t\t          started in bursting mode")
    print("\t\tconfig_path: if equal to a valid file path, a corresponding instance")
    print("\t\t             of pam_interface::JsonConfiguration will be used")
    print("\t\tplotting: if equal to 'plotting', no standalone will be")
    print("\t\t          started. Plotting will be started instead")
    print("\n")


def _run(args):

    if any([s in args
            for s in ("help","--help","-help","-h","--h","man")]):
        _help()
        return
    
    config = _parse_args(args)
    config.display()

    if config.plotting:
        _plot(config.segment_id,
              config.frequency,
              config.config,
              config.nb_dofs,
              config.window,
              config.data_size)
        return

    console = True
    _start_robot(config,
                 console)

    
if __name__ == "__main__":

    args = sys.argv[1:]
    _run(args)
        
