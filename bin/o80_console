#!/usr/bin/env python

import time
import o80
import o80_pam

from lightargs import Brightargs,Set,Range,Positive
import curses


class _Monitor:
    # Hosts "global" variables:
    #    - _running : to be set to false to stop console,
    #               plotting and standalone
    #    - _error : global error message to be displayed
    #               in the console
    _running = True
    _error = None
    @classmethod
    def running(cls):
        return cls._running
    @classmethod
    def stop(cls):
        cls._running = False
    @classmethod
    def error(cls):
        return cls._error
    @classmethod
    def set_error(cls,error):
        cls._error = str(error)

        
def _get_status(frontend,config):
    # returning "status", i.e. a string
    # providing desired and observed pressures
    # for each muscle, at well as iteration number and frequency
    # of the standalone.
    observation = frontend.latest()
    iteration = observation.get_iteration()
    frequency = observation.get_frequency()
    observed = observation.get_observed_pressures()
    desired = observation.get_desired_pressures()
    ref_founds = observation.get_references_found()
    positions = observation.get_positions()
    for dof,found in enumerate(ref_founds):
        if not found:
            positions[dof]=None
    s = ["iteration: {} | frequency {}\n".format(iteration,
                                                 frequency)]
    for dof in range(config.nb_dofs):
        d = [dof]
        for ago in [0,1]:
            d.append([observed[dof][ago],
                      desired[dof][ago]])
        position = positions[dof]
        if position is None:
            d.append("*")
        else :
            d.append(position)
        d = "\t".join([str(d_) for d_ in d])
        s.append(d)
    if _Monitor.error() is not None:
        s.append("\nERROR DETECTED:\n\t{}".format(_Monitor.error()))
    return "\t"+"\n\t".join(s),observed


class _Console:

    # manages curses : creates the o80 frontend that is
    # used to extract observation from the robot, and
    # display related selected information in the terminal
    
    _nb_dofs = config.nb_dofs
    _screen = None
    _should_exit = False
    _monitor_exit_thread = None
    _permanent_info = None
    _min_pressure = None
    _max_pressure = None
    _width = None
    _frontend = None


    @classmethod
    def init(cls,
             permanent_info,
             config):
        # creating frontend and initializing curse
        cls._permanent_info = permanent_info
        cls._frontend = o80_pam.FrontEnd(config.segment_id)
        cls._width = config.width
        cls._screen = curses.initscr()
        curses.noecho()
        curses.curs_set(0)
        cls._screen.keypad(1)
        cls._monitor_exit_thread = threading.Thread(target=cls._monitor_exit)
        cls._monitor_exit_thread.setDaemon(True)
        cls._monitor_exit_thread.start()

    @classmethod
    def _monitor_exit(cls):
        # detecting if 'q' was pressed, which set _should_exit
        # to True, which will stop the loop
        while not cls._should_exit:
            event = cls._screen.getch()
            if event == ord("q"):
                cls._should_exit=True

    @classmethod
    def exit(cls):
        # closing curses
        curses.endwin()

    @classmethod
    def _get_dof_str(cls,
                     dof,
                     pressure_plus,
                     pressure_minus):
        # the method that generates the "pressure bars"
        # for each of the dof
        def _get_pressure_str(pressure,
                              min_pressure,
                              max_pressure,
                              width):
            mdiff = (max_pressure-min_pressure)
            diff = pressure-min_pressure
            value = int (width*(diff)/mdiff)
            return '|'*value
        r = []
        for sign,pressure in zip(('+','-'),(pressure_plus,pressure_minus)):
            value = _get_pressure_str( pressure,
                                       cls._min_pressure,
                                       cls._max_pressure,
                                       cls._width) 
            r.append("\t{}{}  {}".format(dof,sign,value))
        return '\n'.join(r)


    @classmethod
    def refresh(cls):
        # The method the construct and display the
        # string information
        if cls._should_exit:
            return
        status,pressures  = _get_status(cls._frontend,config)
        cls._screen.clear()
        cls._screen.addstr(cls._permanent_info+"\n")
        # the "pressure bars"
        for dof in range(config.nb_dofs):
            cls._screen.addstr( cls._get_dof_str(dof,
                                                 pressures[dof][0],
                                                 pressures[dof][1]) )
            cls._screen.addstr('\n\n')
        # the status (iteration, frequency, observed/desired pressues)
        cls._screen.addstr(status)
        try :
            cls._screen.refresh()
        except:
            print("\n\n\nFAILED CONSOLE\n|"{}"|\n\n\n".format(status))


def _permanent_info(config):
    if config.bursting_mode:
        bursting_str = " (bursting mode)"
    else:
        bursting_str = ""
    permanent_info = str("\n\to80 pam | segment_id: {}{}"+
                         "\n\t(press q to exit)").format(config.segment_id,
                                                         bursting_mode)
    return permanent_info


def _console(config):
    # Create a frontend on the segment_id, get observations
    # and displays important information on the terminal.
    _Console.init(_permanent_info(config),
                  config)
    while _Monitor.running() :
        if _Console._should_exit:
            _Monitor.stop()
            break
        _Console.refresh()
        time.sleep(0.05)

    _Console.exit()



def _configure():
    config = BrightArgs("o80 PAM console")
    config.add_option("segment_id",
                      o80_pam.segment_ids.robot,
                      "o80 segment_id of the instance of o80 pam to display",
                      str)
    config.add_operation("bursting mode",
                         "is the related backend running in bursting mode ?")
    config.add_option("refresh frequency",
                      100,
                      "refresh rate of the console (Hz)",
                      int,
                      Range(1,1000))
    config.add_option("minimal pressure",
                      5000,
                      "minimal possible muscle pressure, for scaling purposes",
                      int,
                      Positive())
    config.add_option("maximal pressure",
                      25000,
                      "maximal possible muscle pressure, for scaling purposes",
                      int,
                      Positive())
    config.add_option("width",
                      100,
                      "number of characters used for pressure bars",
                      int,
                      Positive())
    config.dialog()
    return config

    
if __name__ == "__main__":

    config = _configure()
    _console(config)

        
